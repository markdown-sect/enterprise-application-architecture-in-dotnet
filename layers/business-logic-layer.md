> ## Уровень бизнес-логики

В результате изменений последних лет произошёл сдвиг от информационно-центрической трёхуровневой архитектуры к более модельно-центрический многоуровневой архмтектуре.

Становятся всё блее популярными _событийно-управляемые (CQRS)_ архитектуры.

В итоге класический уровень бизнес логики, канонически размещающийся между _уровнем представления_ и _уровнем доступа к данным_, превращается во что-то другое, в засимисости от общей архитектуры системы. Но неизменным остаётся то, что так или иначе мы всё ещё должны реализовывать смысловое ядро и бизнес-логику системы в этом слое.

### Тут мы рассмотрим следующие подходы:
1. Источник мобытий
2. CQRS
3. Предметно-ориентированное проектирование (DDD)

<details>
  <summary>Шаблоны</summary>

*   <details>
    <summary>Шаблон сценарий транзакций (Transaction Script)</summary>

    Это, вероятно, самый простой шаблон для описания бизнес-логики, и при этом полностью **процедурный** _(а не объекто-ориентированный)_

    Данный шаблон поощряет игнорировать любой объектно-ориентированный подход и отображать бизнес-компоненты непосредственно в требуемые пользовательские действия. Вся бизнес-логика нашего приложения разбивается на **процедуры (сервисы)**, каждая из которых соответствует конкретному запросу, поступающему из _уровня презентации_

    Подходит для простых сценариев с прямой бизнес-логикой, которая не будет меняться и эволюционировтать.

    > ### Пример
    ```csharp
        public interface IApplicationCommand
        {
            int Run();
        }

        public class BookHotelRoom : IApplicationCommand
        {
            private readonly Customer _guest;
            private readonly DateTime _checkIn;
            private readonly DateTime _checkOut;
            private string _confirmationNumber;

            public BookHotelRoom(Customer guest, DateTime checkIn, DateTime checkOut)
            {
                _guest = guest;
                _checkIn = checkIn;
                _checkOut = checkOut;
            }

            public string ConfirmationNumber => _confirmationNumber;

            public int Run()
            {
                // начало транзакции
                // проверяем наличие комнат
                // проверяем информацию клиента (уже поселён, способ оплаты, предпочтения)
                // вычисляем стоимость номера
                // добавляем новую запись в таблицу базы данных Bookings
                // генерируем номер квитанции
                // завершаем транзакцию
                // посылаем e-mail клиенту
                // сохраняем номер квитанции в локальной переменной _confirmationNumber
            }
        }
    ```
    </details>

*   <details>
    <summary>Шаблон Модель Предметной Области (Domain Model)</summary>

    Данный шаблон предполагает, чтобы архитекторы фокусировались на ожидаемом поведении системы и на потоках джанных, лежащих в основе её работы. 

    То есть, мы просто пытаемся воспроизвести работу предметной области с помощью классов.

    Модель предметной области - это не объектная модель, созданная из набора связных классов.
    Это модель, котоаря точно описывает предметную область, _особенно процессы_, протекающие в ней.

    Главный фактор, который стоит учитывать при выборе в пользу шаблона Модели Предметной Области - сложность.
    Работа с данным шаблоном в _простом проекте_ приводит к **дополнительным затратам**, но в _крупных системах_ затраты на его настройку и обслуживание более чем **компенсируются**.

    Модель предметной области - это набор обычных классов, каждый из которых представляет важную сущность в предметной области. Для описания классов в предметной области часто используют термин **POCO (Plain Old CLR Object)**

    > ### Anemic Domain Model
        В сущностях есть только свойства, но нет методов.

    > ### Rich Domain Model
        В сущностях присутствуют как свойства, так и методы.
</details>

</details>

