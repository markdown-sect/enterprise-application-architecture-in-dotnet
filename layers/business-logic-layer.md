# Уровень бизнес-логики

В результате изменений последних лет произошёл сдвиг от информационно-центрической трёхуровневой архитектуры к более модельно-центрический многоуровневой архмтектуре.

Становятся всё блее популярными _событийно-управляемые_ архитектуры.

В итоге класический уровень бизнес логики, канонически размещающийся между _уровнем представления_ и _уровнем доступа к данным_, превращается во что-то другое, в засимисости от общей архитектуры системы. Но неизменным остаётся то, что так или иначе мы всё ещё должны реализовывать смысловое ядро и бизнес-логику системы в этом слое.

### Тут мы рассмотрим следующие подходы

1. Источник cобытий
2. CQRS (Command Query Responsibility Segregation)
3. Предметно-ориентированное проектирование (Domen-Driven Design | DDD)

<details>
  <summary>Шаблоны</summary>

* <details>
    <summary>Шаблон сценарий транзакций (Transaction Script)</summary>

    Это, вероятно, самый простой шаблон для описания бизнес-логики, и при этом полностью **процедурный** _(а не объекто-ориентированный)_

    Данный шаблон поощряет игнорировать любой объектно-ориентированный подход и отображать бизнес-компоненты непосредственно в требуемые пользовательские действия. Вся бизнес-логика нашего приложения разбивается на **процедуры (сервисы)**, каждая из которых соответствует конкретному запросу, поступающему из _уровня презентации_

    Подходит для простых сценариев с прямой бизнес-логикой, которая не будет меняться и эволюционировтать.

    > ### Пример

    ```csharp
        public interface IApplicationCommand
        {
            int Run();
        }

        public class BookHotelRoom : IApplicationCommand
        {
            private readonly Customer _guest;
            private readonly DateTime _checkIn;
            private readonly DateTime _checkOut;
            private string _confirmationNumber;

            public BookHotelRoom(Customer guest, DateTime checkIn, DateTime checkOut)
            {
                _guest = guest;
                _checkIn = checkIn;
                _checkOut = checkOut;
            }

            public string ConfirmationNumber => _confirmationNumber;

            public int Run()
            {
                // начало транзакции
                // проверяем наличие комнат
                // проверяем информацию клиента (уже поселён, способ оплаты, предпочтения)
                // вычисляем стоимость номера
                // добавляем новую запись в таблицу базы данных Bookings
                // генерируем номер квитанции
                // завершаем транзакцию
                // посылаем e-mail клиенту
                // сохраняем номер квитанции в локальной переменной _confirmationNumber
            }
        }
    ```

    </details>

* <details>
    <summary>Шаблон Модель Предметной Области (Domain Model)</summary>

    Данный шаблон предполагает, чтобы архитекторы фокусировались на ожидаемом поведении системы и на потоках джанных, лежащих в основе её работы.

    То есть, мы просто пытаемся воспроизвести работу предметной области с помощью классов.

    Модель предметной области - это не объектная модель, созданная из набора связных классов.
    Это модель, котоаря точно описывает предметную область, _особенно процессы_, протекающие в ней.

    Главный фактор, который стоит учитывать при выборе в пользу шаблона Модели Предметной Области - сложность.
    Работа с данным шаблоном в _простом проекте_ приводит к **дополнительным затратам**, но в _крупных системах_ затраты на его настройку и обслуживание более чем **компенсируются**.

    Модель предметной области - это набор обычных классов, каждый из которых представляет важную сущность в предметной области. Для описания классов в предметной области часто используют термин **POCO (Plain Old CLR Object)**

    > ### Anemic Domain Model

        В сущностях есть только свойства, но нет методов.

    > ### Rich Domain Model

        В сущностях присутствуют как свойства, так и методы.

</details>

</details>

Для передачи данных между уровнями (ярусами) используются DTO объекты.
Для облегчения работы с DTO используются адаптеры для генерации DTO. Например, `AutoMapper`.

## Механизмы перемещения даных

### `AutoMapper`

Функции AutoMapper:

1. Создание отображения между исходным и целевым типом;
2. Вызов процедуры отображения, чтобы заполнить экземпляр целевого типа данными, хранящимися в экземпляре исходного типа.

Минус AutoMapper заключается в том, что когда вы просите, чтобы он создала объект DTO из сущности, он вынужден **выполнить обход графа сущностей, который должен находиться в памяти и поэтому должен быть загружен из хранилища**

### `IQueryable`

Функции IQueryable:

1. Возвращает объекты класса IQueryable из хранилищ;
2. Позволяет вышестоящим уровням создавать разные виды запросов более простым способом;
3. Позволяет упростить интерфейсы хранилищ и уменьшить потребность в объектах DTO, т.к. некоторые из них могут иметь анонимные типы.

## Резюме

Говоря об этом уровне, мы пришли к классической диллеме: делать правильные вещи или делать вещи правильно.

Делать вещи правильно - это принцип _уровня представления_. Он является сутью эффективности: выполнять задачи оптимальным способом, быстро и гибко.

Делать правильные вещи - это принцип _уровня бизнес-логики_. Он относится к достижению цели и **успеха**.
