# Уровень постоянного хранения

**Уровень постоянного хранения** - это та часть кода, которая знает о деталях доступа к данным: строки подключаения, языки запросов, индексы, структуры данных JSON и т.д.

## Обазянность уровня постоянного хранения

> Уровень постоянного хранения имеет связи с уровнем предметной области (слежбами) и с прикладным уровнем.

1. Сохранение постоянных данных
2. Обработка транзакций

    - Уровень постоянного хранения должен заботиться об обновлении многочисленных таблиц в пределах границ агрегата в отдельной единице работы.
    - Уровень постоянного хранения не должен быть вовлечён в обработку более широких транзакций, которые вовлекают другие компоненты.

3. Чтение постоянных данных

## Шаблон Хранилище (Repository)

Repository - класс, в котором каждый метод представляет действие относительно источника данных.

> Репозиторий - это хранилище, которое является посредником между моделью предметной области и уровнями отображения данных, и использует интерфейс для обеспечения доступа к объектам предметной области.

### Плюсы хранилища

- Репозиторий обеспечивает разделение обязанностей
- Репозиторий уменьшает вероятность дублирования кода доступа к данным

### Минусы хранилища

- Репозиторий увеличивает количество тестируемого кода в приложении и на уровне предметной области

### Шаблон единица работы

Единица работы - это список операций, образующих деловую транзакцию. Компонент, который поддерживает этот шаблон, координирует запись изменений в единственной физической транзакции, включая решение проблем параллельной работы.

Примером модуля работы может стать `DbContext` - класса из Entiry Framework, который будет сохранять работу во время выполнения транзакции, вызывая метод `.SaveChanges()`.

#### Пример

```csharp
public interface IOrderRepository : IRepository<Order>
{
    /* Методы запроса */

    /* Методы команды */
    void Save(Order aggregate);

    /* Транзакционные методы */
    void Commit();
}

public class OrderRepository : IOrderRepository
{
    protected IOrdersContext _ordersContext;

    public OrderRepository(IOrdersContext ordersContext)
    {
        _ordersContext = ordersContext;
    }

    public void Save(Order order)
    {
        _ordersContext.Orders.Save();
    }

    public void Commit()
    {
        _ordersContext.SaveChanges();
    }
}
```

## Интерфейс хранилища

```csharp
public interface IRepository<TAggragate, in TKey>
    where TAggregate : IAggregateRoot
{
    TAggregate Get(TKey id);
    void Save(TAggregate aggregate);
    void Delete(TAggregate aggregate);

    IEnumerable<TAggregate> FindBy(Expression<Func<TAggregate, bool>> predicate);
}
```

`IAggregateRoot` - не является строго необходимым, можно использовать просто `where TAggregate : class`.

### Асинхронные методы запроса

- Асинхронные операции базы данных можно применять, если операции выполняются долго или задержки сети могут блокировать приложение
- Асинхронные операции базы данных можно применять для того, чтобы уменьшить время блокировки, создавая вручную многочисленные потоки для **параллельного** выполнения операций

> #### Асинхронные операции, встроенные на уровне .NET, используют системные потоки для ожидания операция, не влияя на выполнение самого приложения

### Возвращение IQueryable

Возвращение объектов типа IQueryable из хранилища вместо результатов фактического запроса к базе данных обеспечивает намного большую гибкость.

#### Плюсы IQueryable

- Высокая производительность и ясность кода
- Фактический потребитель данных берёт на себя ответственность сужения резальтатов до тех, которые фактически необходимы
- Фильтрация выполняется лишь в тот момент, когда его больше нельзя откладывать, то есть фактически перед моментом использования данных запроса

#### Минусы IQueryable

- Программы, вызывающие хранилища, фактически получают неограниченные возможности
- Злоупотребление методом `.Inculde` может сильно наращивать граф возвращаемых объектов
- Появляется зависимость от конкретного LINQ провайдера, реализуюшего доступ к базе данных

```csharp
public interface IRepository<TAggregate>
{
    IQueryable<TAggregate> All();
}
```

На самом деле, реализация таких хранилищ встречается довольно редко, потому что она не эффективна и не всегда целесообразна.

## Распределённый кеш памяти

Хранилище - это место, где при необходимости используется _кеширование_.

### Типичный сценарий с использованием кеширования

1. Попробуйте прочитать данные из кеша
2. Если никакие данные не найдены, обратитесь во внутреннее хранилище
3. Сохраните данные в кеше
4. Верните данные

## Хранилище данных NoSQL

- Такие хранилища обычно используются для того, чтобы хранить огромные количества данных любого формата, любого размера и сложности
- Они не подчиняются фиксированной схеме и позволяют свободно развивать систему

### Плюсы NoSQL

1. Способность работать с неструктурированными данными
2. Способность поддерживать возможные сценарии **непротиворечивости**, которая уменьшаем время записи и облегчает масштабирование сосиемы
3. Независимость от языка запросов

## Конечная непротиворечивость

**Конечная непротиворечивость (eventual consistensy)** означает, что операции чтения и записи не относятся к одним и тем же данным.